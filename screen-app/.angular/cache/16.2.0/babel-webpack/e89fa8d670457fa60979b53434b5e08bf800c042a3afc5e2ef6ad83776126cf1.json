{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ergun/OneDrive/Desktop/okulum.cloud/screen-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\n// Lightweight IndexedDB wrapper for small JSON blobs.\nexport let CacheService = /*#__PURE__*/(() => {\n  class CacheService {\n    constructor() {\n      this.dbName = 'screen-app-cache';\n      this.storeName = 'kv';\n    }\n    openDb() {\n      return new Promise((resolve, reject) => {\n        if (!('indexedDB' in window)) return reject(new Error('IndexedDB not supported'));\n        const req = indexedDB.open(this.dbName, 1);\n        req.onupgradeneeded = ev => {\n          const db = ev.target.result;\n          if (!db.objectStoreNames.contains(this.storeName)) {\n            db.createObjectStore(this.storeName, {\n              keyPath: 'key'\n            });\n          }\n        };\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    }\n    set(schoolId, type, value) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const db = yield _this.openDb();\n          const tx = db.transaction(_this.storeName, 'readwrite');\n          const store = tx.objectStore(_this.storeName);\n          const key = `${schoolId ?? 'global'}:${type}`;\n          store.put({\n            key,\n            value,\n            updatedAt: Date.now()\n          });\n          return new Promise((resolve, reject) => {\n            tx.oncomplete = () => {\n              db.close();\n              resolve();\n            };\n            tx.onerror = () => {\n              db.close();\n              reject(tx.error);\n            };\n          });\n        } catch (err) {\n          // silently ignore cache failures\n          return Promise.resolve();\n        }\n      })();\n    }\n    get(schoolId, type) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const db = yield _this2.openDb();\n          return new Promise((resolve, reject) => {\n            const tx = db.transaction(_this2.storeName, 'readonly');\n            const store = tx.objectStore(_this2.storeName);\n            const key = `${schoolId ?? 'global'}:${type}`;\n            const req = store.get(key);\n            req.onsuccess = () => {\n              db.close();\n              resolve(req.result ? req.result.value : null);\n            };\n            req.onerror = () => {\n              db.close();\n              reject(req.error);\n            };\n          });\n        } catch (err) {\n          return null;\n        }\n      })();\n    }\n    // Optional helper to clear a cached key\n    delete(schoolId, type) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const db = yield _this3.openDb();\n          const tx = db.transaction(_this3.storeName, 'readwrite');\n          const store = tx.objectStore(_this3.storeName);\n          const key = `${schoolId ?? 'global'}:${type}`;\n          store.delete(key);\n          return new Promise((resolve, reject) => {\n            tx.oncomplete = () => {\n              db.close();\n              resolve();\n            };\n            tx.onerror = () => {\n              db.close();\n              reject(tx.error);\n            };\n          });\n        } catch (err) {\n          return Promise.resolve();\n        }\n      })();\n    }\n    static {\n      this.ɵfac = function CacheService_Factory(t) {\n        return new (t || CacheService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: CacheService,\n        factory: CacheService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return CacheService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}